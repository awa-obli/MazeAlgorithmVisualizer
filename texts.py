"""
文本内容
"""

# 算法介绍文本
ALGORITHM_INFO = {
    "title": "🧩 迷宫算法介绍",
    "subtitle": "by awa",
    
    "generation": {
        "title": "📌 迷宫生成算法",
        "dfs": {
            "title": "1. 深度优先搜索 (DFS)",
            "content": """核心思想：随机深度优先遍历，从起点开始随机选择方向前进，遇到死路时回溯，直到所有格子都被访问。

执行流程：
1. 初始化迷宫，将所有内部行列坐标为偶数的格子设为墙壁
2. 选择起始格点压入栈中，标记为已访问
3. 获取栈顶格点，随机打乱四个方向的顺序
4. 遍历每个方向：
   - 若该方向连接的格点的位置在迷宫范围内且未访问
   - 则打通中间的墙壁，将新格点入栈并标记为已访问
5. 若当前格点无未访问的相邻格点，则将其出栈
6. 重复步骤3-5，直到栈为空

特点：迷宫分支较少，死路较多，难度大。"""
        },
        "prim": {
            "title": "2. Prim算法",
            "content": """核心思想：最小生成树，维护一个边界墙序列，不断随机打通边界墙，并将新边界墙加入序列，直到连接所有格点。

执行流程：
1. 初始化迷宫，将所有内部行列坐标为偶数的格子设为墙壁
2. 选择起始格点，将其所有相邻的墙壁加入候选列表
3. 从候选列表中随机选择一面墙壁，并将其从候选列表中移除：
   - 若墙壁连接的另一个格点在迷宫范围内且未访问
   - 则打通这面墙壁，标记新格点为已访问
   - 并将新格点相邻的墙壁加入候选列表
4. 重复步骤3，直到候选列表为空

特点：生成的迷宫结构均匀，分支丰富，更自然。"""
        },
        "kruskal": {
            "title": "3. Kruskal算法",
            "content": """核心思想：最小生成树，将每个单元格视为一个集合，随机选择墙壁，如果墙壁连接的两个单元格属于不同集合，则打通墙壁并合并集合，直到所有单元格连通。

执行流程：
1. 初始化迷宫，将所有内部行列坐标为偶数的格子设为墙壁
2. 将所有可通行的单元格（奇数坐标）初始化为独立的集合（并查集）
3. 收集所有可能的墙壁（相邻单元格之间的墙）
4. 随机打乱墙壁顺序
5. 遍历每面墙壁：
- 若墙壁连接的两个单元格属于不同集合
- 则打通这面墙壁，合并两个集合
6. 重复直到所有墙壁检查完毕

特点：生成的迷宫分支丰富，结构自然，与Prim类似。"""
        },
        "recursive": {
            "title": "4. 递归分割",
            "content": """思路：将空间用十字分成四个子空间，在三面墙上挖洞，递归分割直到空间不足。

流程：
1. 初始化迷宫，内部均为空地
2. 递归函数：
   - 终止条件：子空间行列范围不足3个格点
   - 确定分割位置（偶数）
   - 建造十字墙壁
   - 随机打通三面墙（奇数，避免被新十字墙壁阻塞）
   - 递归分割四个子空间

特点：生成速度快，生成的迷宫结构规整，通常比较简单。"""
        }
    },

    "pathfinding": {
        "title": "📌 迷宫寻路算法",
        "dfs": {
            "title": "1. 深度优先搜索 (DFS)",
            "content": """思路：维护一个栈，从起点开始不断前进（入栈），走不通就回溯（出栈），尝试其他方向。

流程：
1. 将起点压栈，记录已访问
2. 栈不为空：
   - 获取当前栈顶格点
   - 打乱四个方向顺序
   - 遍历方向：若相邻格点在迷宫范围内、为通路且未访问 →
       入栈、记录已访问
       - 若到达终点 → 返回当前栈作为路径
   - 若无可访问方向 → 出栈（回溯）
3. 栈空 -> 寻路失败

特点：实现简单，但找到的不一定是最短路径。"""
        },
        "bfs": {
            "title": "2. 广度优先搜索 (BFS)",
            "content": """思路：维护一个队列，从起点开始逐层向外扩散搜索（将所有邻居格点入队）。

流程：
1. 初始化队列，将起点入队，记录前驱格点
2. 队列不为空：
   - 取出队首格点
   - 遍历四个方向：若相邻格点在迷宫范围内、为通路且未访问 →
       入队、记录前驱、标记已访问
       - 若到达终点 → 回溯前驱构建完整路径并返回
3. 队列空 -> 寻路失败

特点：保证找到最短路径，但内存占用较大。"""
        },
        "dijkstra": {
            "title": "3. dijkstra算法",
            "content": """思路：始终选择当前距离起点最近的格子进行探索，并更新其相邻格子的距离。

流程：
1. 初始化优先队列，加入起点
2. 优先队列不为空：
   - 取出距离最近的格点作为当前格点
   - 若当前格点为终点 → 回溯路径并返回
   - 遍历四个方向：若相邻格点在范围内且为通路 →
       计算起点到相邻格点的距离 = 当前格点 + 1
       - 若该格点未被访问过或新路径的距离比之前更小 →
         把该格点加入到优先队列里，优先级为距离
3. 优先队列空 -> 寻路失败

特点：保证找到最短路径。
注意：由于二维网格迷宫中所有边权重相同，在这里dijkstra寻路和bfs寻路无异！"""
        },
        "astar": {
            "title": "4. A*算法",
            "content": """思路：估计总代价（分为当前代价和预估代价），优先探索总代价最小的方向。相当于进阶版dijkstra。

流程：
1. 初始化优先队列，加入起点
2. 优先队列不为空：
   - 取出估计总代价最小的格点作为当前格点
   - 若当前格点为终点 → 回溯路径并返回
   - 遍历四个方向：若相邻格点在范围内且为通路 →
       计算当前代价 = 之前代价 + 1
       - 若该格点未被访问过或新代价比之前更小 →
         把该格点加入到优先队列里，总代价=当前代价+预估代价（曼哈顿距离）
3. 优先队列空 -> 寻路失败

特点：效率高，路径最优，适合大多数场景下的路径搜索。"""
        }
    },

    "comparison": {
        "title": "📊 算法对比",
        "generation": {
            "title": "迷宫生成算法",
            "headers": ["算法", "核心思想", "特点"],
            "data": [
                {
                    "algorithm": "DFS",
                    "idea": "随机深度优先",
                    "features": "• 死路多，分支少\n• 难度高"
                },
                {
                    "algorithm": "Prim",
                    "idea": "随机最小生成树",
                    "features": "• 分支均匀，岔路多\n• 结构自然"
                },
                {
                    "algorithm": "Kruskal",
                    "idea": "随机最小生成树",
                    "features": "• 与Prim类似"
                },
                {
                    "algorithm": "递归分割",
                    "idea": "分治建墙挖洞",
                    "features": "• 结构规整\n• 生成速度快"
                }
            ]
        },
        "pathfinding": {
            "title": "迷宫寻路算法",
            "headers": ["算法", "核心思想", "特点"],
            "data": [
                {
                    "algorithm": "DFS",
                    "idea": "一条路走到黑",
                    "features": "• 一条路走到黑\n• 不一定是最短路径\n• 内存占用小"
                },
                {
                    "algorithm": "BFS",
                    "idea": "层层扩散",
                    "features": "• 地毯式搜索\n• 保证最短路径\n• 内存占用大"
                },
                {
                    "algorithm": "Dijkstra",
                    "idea": "贪心策略",
                    "features": "• 优先看最近格点\n• 保证最短路径\n• 适用于带权图"
                },
                {
                    "algorithm": "A*",
                    "idea": "启发式引导",
                    "features": "• 有方向地搜索\n• 保证最短路径\n• 效率最高"
                }
            ]
        }
    }
}


# 关于对话框文本
ABOUT_INFO = {
    "title": "🧩 迷宫算法可视化工具",
    "subtitle": "by awa",
    "version": "1.5.3",
    "introduction": """
本项目是一个用于学习和演示迷宫生成算法与寻路算法的交互式工具，使用tkinter编写。
将算法以可视化的方式逐步执行，帮助学习者理解算法思想。
    """,
    "features": [
        "• 多种迷宫生成算法：DFS、Prim、Kruskal、递归分割",
        "• 多种寻路算法：DFS、BFS、Dijkstra、A*",
        "• 实时可视化算法执行过程",
        "• 自定义迷宫大小（最大101×101）",
        "• 可编辑迷宫（左键切换墙壁/路径）",
        "• 自定义起点/终点（右键点击路径）",
        "• 迷宫编码/解码，方便分享",
        "• 缩放、平移查看功能",
        "• 可调节动画速度",
        "• 可暂停动画",
    ],
    "tips": [
        "• 鼠标滚轮：垂直滚动画布",
        "• Ctrl + 滚轮：缩放画布",
        "• 鼠标中键拖拽：平移画布",
        "• 左键点击/拖拽：编辑墙壁",
        "• 右键点击路径：设置起点/终点"
    ],
    "copyright": "© 2026 MazeAlgorithmVisualizer",
    "license": "本软件为开源项目，遵循 MIT 许可证",
    "github_url": "https://github.com/awa-obli/MazeAlgorithmVisualizer"
}
